import numpy as np
import matplotlib.pyplot as plt

def dp_beta(dataset, b, eps):
    # Clip the data to the interval [-b, b]
    n_rows = len(dataset)
    clip = [[min(max(val, -b), b) for val in row] for row in dataset]

    # Compute the sufficient statistics
    S_xy = 0.0
    S_xx = 0.0
    for i in range(n_rows):
        x_val = clip[i][0]
        y_val = clip[i][1]
        S_xy += x_val * y_val
        S_xx += x_val * x_val
    
    # Sensitivities (with one row change):
    # Sensitivity for S_xy is 2*b^2, for S_xx is b^2.
    # Split the privacy budget equally: eps1 = eps/2, eps2 = eps/2.
    # Hence, noise scale for S_xy: 2*b^2 / (eps/2) = 4*b^2/eps,
    # and for S_xx: b^2 / (eps/2) = 2*b^2/eps.
    xy_scale = 4 * b**2 / eps
    xx_scale = 2 * b**2 / eps
    
    S_xy_noise = S_xy + np.random.laplace(loc=0, scale=xy_scale)
    S_xx_noise = S_xx + np.random.laplace(loc=0, scale=xx_scale)
    
    # Avoid division by zero (or very small denominator)
    if abs(S_xx_noise) < 1e-6:
        return 0.0
    return S_xy_noise / S_xx_noise

def ols_regression(dataset):
    total_xy = 0.0
    total_xx = 0.0
    n_rows = len(dataset)
    for i in range(n_rows):
        x_val = dataset[i][0]
        y_val = dataset[i][1]
        total_xy += x_val * y_val
        total_xx += x_val * x_val
    if total_xx == 0:
        return 0.0
    return total_xy / total_xx

# Monte Carlo simulation parameters
trials = 1000  # number of Monte Carlo trials for each sample size
sample_sizes = list(range(100, 5001, 100))  # sample sizes from 100 to 5000

# Lists to store bias and standard deviation for OLS and DP estimates
ols_bias_vals = []
ols_std_vals = []
dp_bias_vals = []
dp_std_vals = []

for n in sample_sizes:
    ols_results = []
    dp_results = []
    # Run a number of trials for each sample size
    for t in range(trials):
        # Generate synthetic dataset using loops
        X = []
        Y = []
        for i in range(n):
            # x is drawn uniformly from [-0.5, 0.5]
            x_val = np.random.uniform(-0.5, 0.5)
            # y is generated as x + noise (with noise ~ N(0, sqrt(0.02)))
            noise_val = np.random.normal(0, np.sqrt(0.02))
            y_val = x_val + noise_val
            X.append(x_val)
            Y.append(y_val)
        # Build the dataset as a list of [x, y] rows
        current_data = []
        for i in range(n):
            current_data.append([X[i], Y[i]])
        
        # Compute the OLS and DP estimates for the current dataset
        est_ols = ols_regression(current_data)
        est_dp = dp_beta(current_data, 1.0, 0.1)
        
        ols_results.append(est_ols)
        dp_results.append(est_dp)
    
    # Compute mean (bias) and standard deviation using loops for each sample size:
    # Calculate the mean of OLS estimates
    mean_ols = 0.0
    for val in ols_results:
        mean_ols += val
    mean_ols /= len(ols_results)
    
    mean_dp = 0.0
    for val in dp_results:
        mean_dp += val
    mean_dp /= len(dp_results)
    
    # Bias = mean estimate minus the true value (1.0)
    ols_bias_vals.append(mean_ols - 1.0)
    dp_bias_vals.append(mean_dp - 1.0)
    
    # Calculate standard deviation for OLS estimates
    var_ols = 0.0
    for val in ols_results:
        var_ols += (val - mean_ols)**2
    var_ols /= len(ols_results)
    std_ols = var_ols**0.5
    
    var_dp = 0.0
    for val in dp_results:
        var_dp += (val - mean_dp)**2
    var_dp /= len(dp_results)
    std_dp = var_dp**0.5
    
    ols_std_vals.append(std_ols)
    dp_std_vals.append(std_dp)

# Plotting the results
plt.figure(figsize=(12, 6))

# Plot bias as a function of sample size
plt.subplot(1, 2, 1)
plt.plot(sample_sizes, ols_bias_vals, label='OLS Bias', marker='o')
plt.plot(sample_sizes, dp_bias_vals, label='DP Bias', marker='o')
plt.axhline(0, color='black', linestyle='--')
plt.ylim(-1.0, 1.0)
plt.xlabel('Sample Size (n)')
plt.ylabel('Bias (Mean Error)')
plt.title('Bias vs Sample Size')
plt.legend()

# Plot standard deviation as a function of sample size
plt.subplot(1, 2, 2)
plt.plot(sample_sizes, ols_std_vals, label='OLS Std', marker='o')
plt.plot(sample_sizes, dp_std_vals, label='DP Std', marker='o')
plt.ylim(0, 1.0)  # standard deviation is always non-negative
plt.xlabel('Sample Size (n)')
plt.ylabel('Standard Deviation')
plt.title('Standard Deviation vs Sample Size')
plt.legend()

plt.tight_layout()
plt.show()